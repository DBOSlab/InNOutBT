#' Produces BayesTraits mean and linked input data comprising samples of trait data
#'
#' @author Domingos Cardoso & Matt Lavin
#'
#' @description This script produces BayesTraits input data that comprise samples
#' of trait data for phylogenetic regression analyses with Meade & Pagel's (2022) [BayesTraits](http://www.evolution.reading.ac.uk/BayesTraitsV4.0.0/BayesTraitsV4.0.0.html)
#' program. The function generates two text files. One includes linked samples of
#' trait data and the other the mean values for samples of trait data. The function
#' also includes an argument to calculate the net node count for each species or
#' terminal taxon given a phylogenetic tree. Net nodes can serve as an explanatory
#' variable to explore the effect of speciation rates on the response variable
#' (e.g., [Oâ€™Donovan et al. 2018](https://doi.org/10.1038/s41559-017-0454-6)).
#' See [BayesTraits V4.0.0 Manual](http://www.evolution.reading.ac.uk/BayesTraitsV4.0.0/Files/BayesTraitsV4.0.0-Manual.pdf)
#' for further details on the specific format of the input files that are required
#' by BayesTraits. See also a more complete article on how to automatically
#' [create input files ](https://dboslab.github.io/InNOutBT/articles/independent_contrast_regression_inputs.html)
#' with \code{BayesTraits.inputs} for the phylogenetic regression analyses.
#'
#' @usage
#' BayesTraits.inputs(tree,
#'                    data,
#'                    tipscol = NULL,
#'                    NodeCount = FALSE,
#'                    logtransf = NULL,
#'                    sqrtransf = NULL,
#'                    traitcols = NULL,
#'                    addtraits = NULL,
#'                    ordtraits = NULL,
#'                    dir_create = "results_BayesTraits_input",
#'                    fileDistData = "BayesTraits_linked_input.txt",
#'                    fileMeanData = "BayesTraits_mean_input.txt",
#'                    fileOrigData = NULL)
#'
#' @param tree The input tree file. This can be either a Newick-formatted tree
#' imported by \code{ape}'s function \code{\link{read.tree}} or a treedata-formatted
#' phylogeny as generated by [BEAST](https://beast.community) and read by
#' \code{treeio}'s function \code{\link{read.beast}}.
#'
#' @param data The input sample of trait data in data frame format.
#' A column is included that links multiple trait values for each terminal branch
#' label of the input phylogeny (i.e., each species or accession).
#'
#' @param tipscol Report the name of the column with terminal or tip labels to be
#' included in the input file containing the mean and linked samples of trait data.
#' Terminal labels on the phylogeny tree have to match row labels in the data files
#' containing mean and linked samples of trait data.
#'
#' @param NodeCount Logical, the default is \code{FALSE}. The function will create
#' a new column NodeCount, or net nodes, for each terminal label. Net nodes or
#' node count will be reported in the mean of the samples of trait data and will
#' be replicated for every accession of each terminal label in the linked samples
#' of trait data.
#'
#' @param logtransf A vector with the name of the column(s) in the original trait
#' data to be log10-transformed. For example, if you report the columns c("DBH", "NodeCount")
#' to be log10-transformed, the function will generate log10DBH and logNodeCount
#' for the BayesTraits input data files.
#'
#' @param sqrtransf A vector with the name of the column(s) in the original trait
#' data to be log10-transformed squared. For example, if you define Nodecount to
#' be log10-transformed squared because speciation rates may have recently slowed,
#' the function will generate sqrNodeCount for the BayesTraits input data containing
#' samples of traits. If sqrNodeCount is to be included in an analysis, list it
#' as argument in \code{addtraits} (see below).
#'
#' @param traitcols A vector with the name of the column(s) in the original trait
#' data that will serve as the response or dependent variable (first column name)
#' and the explanatory or independent variable(s) (second and possibly a third
#' and fourth column) for the phylogenetic regression analysis.
#'
#' @param addtraits A vector with the name of additional column(s) that are not
#' originally in the input trait data but for which you want to generate inputs
#' of linked samples of trait data and mean data. For example, if you have chosen
#' \code{NodeCount=TRUE} and defined any new columns to be log10-transformed or
#' log10-transformed squared, they should be listed here as additional trait data
#' to be included in the linked sample of traits.
#'
#' @param ordtraits A vector listing the order of trait names to be used in the
#' BayesTraits analysis. This ensures that the first trait listed will serve as
#' the response variable, and that subsequently listed traits serve as explanatory
#' variables. Maintaining a consistent order of the names of the explanatory variables
#' among competing nested and non-nested models will facilitate the interpretation of
#' coefficient estimates reported for Beta1, Beta2, etc. in the BayesTraits log files.
#'
#' @param dir_create Path to directory where results will be saved. The default
#' creates a directory named **results_BayesTraits_input** and the results will
#' be saved within a subfolder of that directory named with the current date.
#'
#' @param fileDistData Name of the resulting text file containing linked samples
#' of trait data. If no name is given, the default setting creates a file named
#' *BayesTraits_linked_input.txt*.
#'
#' @param fileMeanData Name of the resulting text file containing mean trait data.
#' If no name is given, the default setting creates a file named *BayesTraits_mean_input.txt*.
#'
#' @param fileOrigData If you define any name here, the originally imported file
#' of trait data will be saved as a CSV file, including any newly generated data
#' columns. This new file of trait data will be written to the directory as set
#' in the argument \code{dir_create}, but outside the current-date subfolder.
#'
#' @seealso \code{\link{BayesTraits.shell}}
#' @seealso \code{\link{BayesTraits.outputs}}
#'
#' @examples
#' \dontrun{
#' library(InNOutBT)
#'
#' ## Loading a example data file
#' data(vatsData)
#'
#' ## Loading a example tree file
#' data(vatsTree)
#'
#' BayesTraits.inputs(tree = vatsTree,
#'                    data = vatsData,
#'                    tipscol = "terminal",
#'                    NodeCount = TRUE,
#'                    logtransf = c("DBH", "NodeCount"),
#'                    traitcols = c("bio12", "bio15"),
#'                    addtraits = c("log10NodeCount", "log10DBH"),
#'                    ordtraits = c("log10DBH", "bio12", "bio15", "log10NodeCount"),
#'                    dir_create = "results_BayesTraits_input",
#'                    fileDistData = "BayesTraits_linked_data_bio12_bio15_nnodes.txt",
#'                    fileMeanData = "BayesTraits_mean_data_bio12_bio15_nnodes.txt",
#'                    fileOrigData = "vataireoids_1610_25May2022_BayesTraits_netnodes_logtransf.csv")
#'}
#'
#' @importFrom magrittr "%>%"
#' @importFrom tibble add_column
#' @importFrom phangorn Ancestors
#' @importFrom stringr str_trunc str_pad
#'
#' @export
#'

BayesTraits.inputs <- function(tree,
                               data,
                               tipscol = NULL,
                               NodeCount = FALSE,
                               logtransf = NULL,
                               sqrtransf = NULL,
                               traitcols = NULL,
                               addtraits = NULL,
                               ordtraits = NULL,
                               dir_create = "results_BayesTraits_input",
                               fileDistData = "BayesTraits_linked_input.txt",
                               fileMeanData = "BayesTraits_mean_input.txt",
                               fileOrigData = NULL) {

  # Get just the tree file if it is as Formal class treedata
  if (class(tree) == "treedata") {
    tree <- tree@phylo
  }

  # Get a vector with the unique terminal names
  terminals <- unique(data[[tipscol]])

  # Checking steps
  # Test whether there is any NA in the trait columns of interest and then stop the function
  cols_to_check <- unique(append(traitcols, logtransf))
  cols_to_check <- cols_to_check[!cols_to_check %in% "NodeCount"]

  NAs <- list()
  NAs_traits <- vector()
  NAs_rows <- list()
  for (i in seq_along(cols_to_check)) {
    NAs[[i]] <- is.na(data[cols_to_check[i]])
    NAs_traits[i] <- any(NAs[[i]])
    NAs_rows[[i]] <- which(is.na(data[cols_to_check[i]]) == TRUE)
  }

  NAs_rows_to_print <- vector()
  for (i in which(NAs_traits == TRUE)) {
    NAs_rows_to_print[i] <- paste0("trait ", cols_to_check[i], ":", " rows ", paste(NAs_rows[[i]], collapse = ", "))
  }
  NAs_rows_to_print <- NAs_rows_to_print[!is.na(NAs_rows_to_print)]
  # Stop the function if NA value is found within any trait column
  if(any(NAs_traits)) {
    stop(paste("\nCell(s) with NA found in the traits",
               paste0(paste(cols_to_check[NAs_traits], collapse = " "), ".\n"), "\n",

               "Please check the following rows of the specified traits:\n", "\n",

               paste(NAs_rows_to_print, collapse = "\n"))
    )
  }

  # Checking whether all names within the column of terminals of the input data
  # matches with the tiplabels in the input tree.
  tf <- which(terminals %in% tree$tip.label == FALSE)
  if(length(tf) > 0) {
    stop(paste("\nAny name within the column", tipscol, "of the input data does not match with the tiplabels of the input tree.\n", "\n",

               "Please check the following unmatched names within input data and correct them according to the input tree:\n", "\n",

               paste(terminals[tf], collapse = "\n"))
    )
  }

  # Get node count for each terminal
  if (NodeCount) {
    data <- tibble::add_column(data, NodeCount = NA, .before = "longitude")

    netnodes <- vector()
    for (i in seq_along(tree$tip.label)) {
      netnodes[i] <- length(phangorn::Ancestors(tree, i, type="all")) - 1
    }
    names(netnodes) <- tree$tip.label

    for (i in seq_along(netnodes)) {
      tf <- data[[tipscol]] %in% names(netnodes)[i]
      data$NodeCount[tf] <- as.numeric(netnodes[i])
    }
  }

  if (!is.null(sqrtransf)) {
    # Make specified variables log10 transformed squared
    for (i in seq_along(sqrtransf)) {
      sqrvalues <- log10(data[[sqrtransf[i]]])^2
      data <- data %>% add_column(!!paste0("sqr", sqrtransf[i]) := sqrvalues,
                                  .after = sqrtransf[i])
    }
  }

  if (!is.null(logtransf)) {
    # Make specified variables log10 transformed
    for (i in seq_along(logtransf)) {
      logvalues <- log10(data[[logtransf[i]]])
      # Using dynamic naming while adding new columns to tibble
      # I have found the solution here: https://stackoverflow.com/questions/55364023/using-dynamic-naming-while-adding-new-columns-to-tibble
      # Read also chapter 19 on quasiquotation at Advanced R book: https://adv-r.hadley.nz/quasiquotation.html?q=!!#the-polite-fiction-of
      data <- data %>% add_column(!!paste0("log10", logtransf[i]) := logvalues,
                                  .after = logtransf[i])
    }
  }

  # Create a first data frame with the columns of interest: terminals and the name linked
  datalinked <- data.frame(terminals=terminals,
                           linked=rep("linked", length(terminals)))

  # Create new empty columns for the defined vector of traits of interest
  # Additional traits for NodeCount or log10-transformed data
  if (!is.null(addtraits)) {
    traitcols <- append(traitcols, addtraits)
    if (!is.null(ordtraits)) {
      traitcols <- ordtraits
    }
  }
  datalinked[traitcols] <- NA

  # Filling in the linked data for each terminal taxon and trait of interest
  for (i in seq_along(terminals)) {

    tf <- data[[tipscol]] %in% terminals[i]

    for (l in seq_along(traitcols)) {
      trait <- paste(data[[traitcols[l]]][tf], collapse=",")
      datalinked[i, traitcols[l]] <- trait
    }
  }

  # Creating the linked data
  # First we will collapse all columns into a single-column-sized dataframe
  linkedinputdata <- datalinked[1]
  names(linkedinputdata) <- "linkedinput"
  for(i in 2:length(names(datalinked))) {
    linkedinputdata$linkedinput <- paste(linkedinputdata$linkedinput,
                                         datalinked[[i]],
                                         sep =" ")
  }

  # Creating the mean data
  meaninputdata <- datalinked[-2]
  # Filling in the linked data for each terminal taxon and trait
  for (i in seq_along(meaninputdata$terminals)) {

    for (l in seq_along(traitcols)) {
      temp_data <- meaninputdata[[traitcols[l]]][i]
      mean_data <- mean(as.numeric(strsplit(temp_data, split = ",")[[1]]))
      meaninputdata[i, traitcols[l]] <- mean_data
    }
  }

  # Calculating the space between the taxon labels and corresponding traits data
  vector.list <- vector("list")
  numtaxlab.list <- vector("list")
  for (i in seq_along(names(meaninputdata))) {
    vector.list <- nchar(meaninputdata[[i]])
    numtaxlab <- data.frame(unlist(vector.list, use.names = FALSE))
    colnames(numtaxlab) <- "numtaxlab"
    numtaxlab.list[[i]] <- numtaxlab

    col_temp <- names(meaninputdata)[i]

    meaninputdata[[col_temp]] <- meaninputdata[[col_temp]] %>%
      stringr::str_trunc(max(numtaxlab.list[[i]][["numtaxlab"]], na.rm = FALSE) + 0) %>% # Just increase this last number if we want to add more space
      stringr::str_pad(max(numtaxlab.list[[i]][["numtaxlab"]], na.rm = FALSE) + 0, "right")
  }

  # Create a new directory to save the results with current date
  # If there is no directory... make one!
  todaydate <- format(Sys.time(), "%d%b%Y")
  if (!dir.exists(paste0(dir_create, "/"))) {
    dir.create(paste0(dir_create, "/"))
  }
  if (!dir.exists(paste0(dir_create, "/", todaydate))) {
    dir.create(paste0(dir_create, "/", todaydate))
  }
  # If directory was created during a previous search, get its name to save results
  folder_name <- paste0(paste0(dir_create, "/"), todaydate)
  print(paste0("Writing '", folder_name, "' on disk."))

  # Save the linked data in .txt format
  fulldistname <- paste0(folder_name, "/", fileDistData)
  print(paste0("Writing the linked data '", fileDistData,"' on disk."))
  write.table(linkedinputdata,
              file = fulldistname,
              quote = FALSE,
              row.names = FALSE,
              col.names = FALSE)

  # Save the mean data in .txt format
  fullmeanname <- paste0(folder_name, "/", fileMeanData)
  print(paste0("Writing the mean data '", fileMeanData, "' on disk."))
  write.table(meaninputdata,
              file = fullmeanname,
              quote = FALSE,
              row.names = FALSE,
              col.names = FALSE,
              sep = "\t")

  if (!is.null(fileOrigData)) {
    print(paste0("Writing the original input traitdata '", fileOrigData,
                 "' on the disk folder ", dir_create))
    write.csv(data,
              file = paste0(dir_create, "/", fileOrigData))
  }
}

